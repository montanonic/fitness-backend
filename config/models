-- TODO:

-- Figure out if it's better for like entities to be separated to be specific
-- to comments or posts, or to be consolidated into a single Like entity with
-- NULLable fields referring either to a CommentId or PostId, as it is now.


-- Search for #EntityName# if you want to instantly be taken to a data entity.
--------------------------------------------------------------------------------

------------------------------------USER INFO-----------------------------------

--------------------------------------------------------------------------------
--#User#

-- | Currently the User entity should contain only critically identifying pieces
-- of information. The intent is to restrict access to the User entity to anyone
-- who isn't themselves that user.

User json
    ident Text -- For Auth through Yesod

    email Text -- must be unique
    password Text

    createdAt UTCTime

    UniqueUser ident
    UniqueUserEmail email

    firstName Text SafeToRemove
    lastName Text SafeToRemove
    dateOfBirth Text SafeToRemove

    deriving Typeable Eq Show
--------------------------------------------------------------------------------
--#UserLog#

UserLog
    user UserId

    update UserUpdate -- UpdateIdent, UpdateEmail, UpdatePassword

    createdAt UTCTime

--------------------------------------------------------------------------------
--#Profile# ; data: Gender

-- Here's the dilemma: When a client accesses a user's profile that is other
-- than the logged-in user's own profile, we must, of course, query and get that
-- other user's information, which means that it will end up in the current
-- client. This is obviously a no-go if we're sending the whole user entity, as
-- that contains private information about the user.

-- It may be wise to circumvent a whole class of privacy concerns by making the
-- Profile entity the Public-facing User entity, containing *only* those fields
-- that a User has decided to make public (under a particular permission
-- regime).

Profile json
    user UserId

    firstName Text
    lastName Text

    dateOfBirth Day

    gender Gender

    createdAt UTCTime default=now() -- redundant, given the User entity:
      -- a User and Profile are created at the same time by postUsersR, and
      -- therefore we don't need this field here.
      -- That said, for the sake of simplicity, it costs very little to include
      -- this rather standard field.

    UniqueProfile user -- We can easily fetch any user's profile by using their
      -- UserId.

--------------------------------------------------------------------------------
--#ProfileLog# ; data: UserUpdate

-- | Prevents data loss from meaningful changes to the Profile entity. Currently
-- omits logging of LogIns and LogOuts, as that seems a bit overboard;
-- however it may be worth discussing the potential value of such a feature.
--
-- Every log action here is an UPDATE.

ProfileLog
    profile ProfileId

    action ProfileUpdate -- UpdateFirstName, UpdateLastName, UpdateEmail,
      -- UpdateDateOfBirth, UpdateGender.
    previousValue Text -- the previous value of the field that was changed.
      -- all values are converted to text so that we don't have to use multiple
      -- fields to satisfy differing data types.

    createdAt UTCTime -- These logs are recorded at the same time a change
      -- is made. Hence, this is the timestamp of the change.

    user UserId SafeToRemove


--------------------------------------------------------------------------------
--#ProfileOptions#

-- | One example of options would be a user's display preferences for their
-- profile in terms of what personal information they want to show on their
-- wall.

-- Leaving this un-implemented for now, while I wait to figure out how to best
-- structure this model.

--------------------------------------------------------------------------------
--#Friendship#

-- It may make sense to turn this entity into a Relationship entity. This is
-- more general and would allow us to account for doctor-patient type
-- relationships. That said, for privacy/security reasons, and probably for data
-- reasons as well, it likely makes more sense to have a separate table for
-- doctors, as they are more likely to be a one-to-many relationship (one
-- doctor, many  patients), and friendships between users are a many-to-many
-- relationship, which is why we have this junction table in the first place
-- (containing foreign keys to each of two users).

Friendship json
    firstUser UserId -- This *must always* be the user who *sent* the friend
      -- request
    secondUser UserId

    isActive Bool -- becomes active when a friend request is
      -- accepted, becomes inactive again if a defriending occurs. We can see
      -- who defriended who in the ProfileLog entity.

    isJustRequest Bool -- tells us if this is only meant to be a friend request.
      -- the data handling must enforce that this is never true when isActive is
      -- true as well. We may choose to create a separate entity for friendship
      -- requests, but it would only really make sense as a transitory data
      -- structure. The whole point of a friendship is showing a relationship
      -- between two users, so we might as well roll the request together with
      -- the friendship entity itself.

    createdAt UTCTime

    whoDefriended UserId Maybe SafeToRemove
    becameFriends UTCTime Maybe SafeToRemove -- if NULL, the first user sent a
      -- request, and the second never accepted.
    updatedAt UTCTime SafeToRemove

    UniqueFriendship firstUser secondUser
    UniqueFriendship' secondUser firstUser -- the opposite permutation prevents
      -- the possibility of the secondUser sending a friend request to the
      -- first, which wouldn't make any sense.

--------------------------------------------------------------------------------
--#FriendshipLog# ; data: FriendshipAction

-- | The idea with this is to make sure that we have a full history of any
-- Friendship-level actions.
-- Logging will only occur when a field in Friendship is overwritten.

FriendshipLog
    friendship FriendshipId
    user UserId -- who performed the action

    action FriendshipAction -- SendRequest, CancelRequest, AcceptRequest,
      -- RejectRequest, or Defriend.

    createdAt UTCTime

    timestamp UTCTime SafeToRemove

--------------------------------------------------------------------------------

----------------------------------NOTIFICATIONS---------------------------------

--------------------------------------------------------------------------------
--#Notification#

--Notification
    --user UserId

    --type -- types of notifications
--------------------------------------------------------------------------------

----------------------------------CONVERSATIONS---------------------------------

--------------------------------------------------------------------------------
--#ConversationUser#

-- | Points a User to a Conversation. When created the isActive field will be
-- true, indicating that they will receive updates to the conversation and it
-- will remain visible to them.

ConversationUser json
    conversation ConversationId
    user UserId

    isActive Bool -- This field determines if the user will have the
      -- conversation displayed in their messages tab within the App.
      -- See documentation for more information on how this field is used.

    createdAt UTCTime
    updatedAt UTCTime Maybe -- Allowed fields: isActive.
      -- If this field is not null, and isActive is false, the user de-activated
      -- the conversation at this time; if isActive is true, then the user at
      -- one point de-activated the conversation, and re-activated it at this
      -- time.

    UniqueConversationUser conversation user -- only 1 user per conversation

--------------------------------------------------------------------------------
--#ConversationMessage#

-- | A single conversation contains 1 or more messages. This table contains
-- each message, along with the Conversation it points to.

ConversationMessage json
    conversation ConversationId
    content Text
    author UserId

    createdAt UTCTime
    updatedAt UTCTime Maybe -- Allowed fields: message(?).
        -- non-null entries in this field will indicate the time the last edit
        -- was made to a message (supposing we allow edits)

--------------------------------------------------------------------------------
--#Conversation#

-- | The entries for this table are sparse. That's because it will be used in
-- SQL Joins to link between the ConversationUsers and ConversationMessages.
-- See the documentation for more information.

Conversation json
    createdAt UTCTime -- conversations will be created when a user first sends a
      -- ConversationMessage to one or more users.
    updatedAt UTCTime Maybe
      -- this field will be updated every time a new message is posted to the
      -- conversation.
      -- Depending on how well this works, we may want to get rid of this field
      -- entirely and get this information solely from the most recent
      -- ConversationMessage entity.

--------------------------------------------------------------------------------

--------------------------------NEWS FEED / WALLS-------------------------------

--------------------------------------------------------------------------------
--#Like#

Like json
    liker UserId

    -- The following does not seem to be the most elegant solution to the
    -- problem of connecting a Like to either a Post or a PostComment.

    -- RULE: A Like can refer to EITHER a Post or a PostComment. Hence, one of
    -- these fields must remain NULL.
    post WallPostId Maybe
    comment PostCommentId Maybe

    createdAt UTCTime

--------------------------------------------------------------------------------
--#PostComment#

-- | I know this sounds like an action but it is not; it should be read as a
-- noun, not a verb. This table references Post Comments to an actual WallPost
-- (identified by the WallPost table). This is a many-to-one relationship.

-- Currently lacks support for Media types.

PostComment json
    post WallPostId
    content Text
    author UserId

    likeCount Int

    -- Unimplemented but we may want to allow for nested comments.
    --nestedUnder PostCommentId Maybe -- Used only if this comment is nested
      -- under another comment, rather than being a top-level comment to the
      -- Post itself.

    createdAt UTCTime
    updatedAt UTCTime Maybe -- Allowed fields: content(?).

--------------------------------------------------------------------------------
--#WallPost#

-- Not named "Post" in order to avoid name-conflicts with the HTTP POST method.
-- Currently lacks support for Media types.

WallPost json
    author UserId
    content Text

    commentCount Int
    likeCount Int

    createdAt UTCTime
    updatedAt UTCTime Maybe -- Allowed fields: content(?).

--------------------------------------------------------------------------------

--------------------------------------MEDIA-------------------------------------

--------------------------------------------------------------------------------
--#Image#

Image
    content ByteString
    title Text Maybe -- "Untitled" if NULL
    uploadedBy UserId

--------------------------------------------------------------------------------
--#Video#

Video
    content ByteString
    title Text Maybe -- "Untitled" if NULL
    uploadedBy UserId
